\newpage

\section{SYS\_07 - eBPF}

\subsection{Motivazioni: Perché osservare ciò che accade nel cluster}
In un sistema moderno basato su container e orchestratori come Kubernetes, 
gli amministratori hanno la necessità di osservare in modo capillare cosa 
accade nel cluster. Le applicazioni risiedono nello spazio utente, mentre 
le operazioni critiche --- gestione dei file, chiamate di rete, accesso alla 
memoria --- transitano tutte attraverso il kernel. Questo rende il kernel 
il punto ideale per ottenere visibilità completa sul comportamento del 
sistema e per intercettare attività sospette, anche quando avvengono al 
di sotto dei servizi visibili all'utente.

\begin{figure}[H]
    \centering
    \includegraphics[width=.7\linewidth]{immagini/SYS_07/kub}
    \caption{Struttura di un cluster Kubernetes: ogni node ospita più pod, ciascuno composto da uno o più container.}
    \label{fig:kub}
\end{figure}


\subsection{Il ruolo del kernel e la necessità di strumenti avanzati}
Il kernel rappresenta il livello intermedio fondamentale tra le applicazioni e l’hardware fisico del sistema.
Le applicazioni operano nello \textit{user space} e non possono accedere direttamente alle risorse di basso
livello come CPU, memoria, dispositivi o filesystem: ogni operazione sensibile deve necessariamente
attraversare il \textit{kernel space} tramite una \textit{system call}.

Questo modello garantisce isolamento e sicurezza, ma implica anche che tutte le attività critiche —
apertura di file, allocazioni di memoria, operazioni di rete, creazione e gestione dei processi —
passino obbligatoriamente dal kernel. Di conseguenza, il kernel diventa il punto di osservazione più
ricco e affidabile per comprendere il comportamento complessivo del sistema.

Tradizionalmente, ottenere visibilità a questo livello richiedeva strumenti complessi o intrusivi
(modifiche al kernel, moduli caricati dinamicamente, debugger o tracer ad alto overhead). La necessità
di soluzioni più sicure, flessibili ed efficienti ha portato all’evoluzione di tecnologie come eBPF,
che consentono di monitorare ed estendere il kernel senza comprometterne la stabilità o le prestazioni.


\begin{figure}[H]
    \centering
    \includegraphics[width=.7\linewidth]{immagini/SYS_07/kernel}
    \caption{Relazione tra user space, kernel space e hardware: le applicazioni operano nello user space e non possono accedere direttamente alle risorse fisiche. Ogni operazione sensibile (file I/O, memoria, rete, gestione processi) passa attraverso il kernel tramite system call, che funge da intermediario unico verso CPU, memoria principale e dispositivi hardware.}
    \label{fig:kernel}
\end{figure}


\subsection{eBPF: Hooks nel kernel e nello user space}
eBPF risolve queste limitazioni consentendo di inserire ``hook'' in punti 
strategici del kernel e, opzionalmente, anche in applicazioni user-space. 
Quando il flusso di esecuzione raggiunge uno di questi hook, il kernel 
invoca un programma eBPF, che può analizzare lo stato corrente, raccogliere 
metriche, verificare condizioni di sicurezza e reagire, il tutto con overhead 
trascurabile.

Gli hook sono quindi un meccanismo sicuro per estendere funzionalità del 
kernel o potenziare la capacità di osservazione senza modificare il 
codice sorgente del kernel stesso.

\begin{figure}[H]
    \centering
    \includegraphics[width=.7\linewidth]{immagini/SYS_07/hook}
    \caption{Schema di un cluster Kubernetes composto da più nodi; ogni node ospita più pod, e ciascun pod contiene uno o più container che eseguono le applicazioni.}

    \label{fig:hook}
\end{figure}


\subsection{Sicurezza e osservabilità: un modello unificato}
Gli eBPF program possono essere agganciati a eventi di varia natura 
(scheduler, syscall, eventi hardware, funzioni user-space, rete). Questo 
permette di:
\begin{itemize}
  \item generare eventi personalizzati per l’osservabilità del sistema;
  \item aggregare metriche direttamente nel kernel senza passare per user space;
  \item individuare comportamenti anomali o sospetti;
  \item reagire immediatamente tramite segnali, blocchi o logging avanzato.
\end{itemize}

\subsection{Tipologie di Hook eBPF}
Gli hook si dividono in due categorie fondamentali: statici e dinamici, sia 
nel kernel che nello user space.

\paragraph{Tracepoints Kernel (statici).}
Sono punti di tracciamento predefiniti inseriti dagli sviluppatori del 
kernel mediante macro specifiche. Offrono un'API stabile attraverso le 
versioni del kernel e non hanno impatto prestazionale se non attivi. 
Sono ideali per monitoraggio continuo, analisi delle performance e debugging 
affidabile.

\paragraph{Kprobes (dinamici).}
Consentono di agganciarsi dinamicamente a quasi qualunque simbolo del 
kernel esportato. Sono estremamente flessibili, ma meno stabili dei 
tracepoint perché legati all’implementazione interna delle funzioni 
del kernel. Sono utili per analisi a bassa granularità e scenari di 
debug avanzato.

\paragraph{USDT (User Statically Defined Tracing).}
Sono tracepoint statici definiti dagli sviluppatori all’interno 
dell’applicazione. Permettono di osservare eventi logici, come 
fallimenti di login, errori applicativi o operazioni rilevanti per la 
business logic.

\paragraph{Uprobes (dinamici).}
Permettono di agganciare funzioni user-space a runtime, senza 
modificare il codice dell’applicazione. Sono l’equivalente user-space 
dei kprobes.

\subsection{Tracepoints nel kernel}
I tracepoint forniscono un’interfaccia stabile per analizzare eventi 
critici del kernel. Sono localizzati in ogni sottosistema: scheduler, 
filesystem, gestione memoria, system call, networking. Ogni tracepoint 
espone file speciali in \texttt{/sys/kernel/debug/tracing}, attraverso cui 
si possono:
\begin{itemize}
  \item abilitarli o disabilitarli;
  \item definire filtri (ad esempio, tracciare solo specifici PID);
  \item leggere il formato dati degli eventi generati.
\end{itemize}

Un classico esempio è il tracepoint \texttt{sys\_enter\_openat}, che registra le 
chiamate di apertura file. Agganciandosi a questo evento con eBPF è 
possibile rilevare tentativi di apertura di file sensibili come 
\texttt{/etc/passwd} e reagire, ad esempio inviando un segnale di terminazione 
al processo interessato.

\subsection{Sviluppo e caricamento di programmi eBPF con libbpf-bootstrap}
Per sviluppare eBPF in C in modo moderno e coerente con le nuove API, si 
utilizza il framework \textit{libbpf-bootstrap}. Questo ambiente offre uno 
scheletro preconfigurato che integra:
\begin{itemize}
  \item esempi di utilizzo di tracepoint, kprobe, uprobe e USDT;
  \item il supporto a BTF (BPF Type Format), necessario per il CO-RE 
    (\textit{Compile Once, Run Everywhere});
  \item strumenti di compilazione, linking e generazione skeleton automatico.
\end{itemize}

Il toolchain include inoltre \texttt{bpftool} per l’ispezione di mappe, 
programmi e oggetti caricati nel kernel.

\newpage
\subsection{Laboratorio: Tracepoint \texttt{openat}}
In questo laboratorio si realizza una semplice forma di \textit{runtime enforcement}
utilizzando un tracepoint del kernel e un programma eBPF. L'idea è quella di
agganciare un programma eBPF al tracepoint \texttt{sys\_enter\_openat}, che viene
attivato ogni volta che un processo invoca la syscall \texttt{openat()} per
aprire un file. Intercettando questo evento direttamente nel kernel, è possibile
ispezionare in tempo reale quale file si sta tentando di aprire e decidere se
permettere o meno l'operazione.

Il programma eBPF, caricato nel kernel tramite lo skeleton generato da
\texttt{libbpf-bootstrap}, viene eseguito ad ogni ingresso nella syscall:
legge in modo sicuro, con le primitive eBPF, il percorso del file passato
come argomento alla \texttt{openat()}, e confronta la stringa ottenuta con il
percorso sensibile \texttt{/etc/passwd}. Se il confronto ha esito positivo,
il programma:
\begin{itemize}
  \item registra l'evento nel sistema di tracing del kernel, ad esempio
        tramite \texttt{bpf\_printk()}, in modo che possa essere osservato
        in \texttt{trace\_pipe};
  \item invia al processo chiamante un segnale di terminazione (SIGKILL)
        utilizzando l'helper \texttt{bpf\_send\_signal()}, impedendo
        di fatto l’accesso al file.
\end{itemize}

Dal lato \textit{user space}, un piccolo loader scritto in C utilizza le API
di \texttt{libbpf} per:
\begin{enumerate}
  \item aprire lo skeleton del programma eBPF e verificarne il bytecode;
  \item caricare il programma nel kernel;
  \item attaccare automaticamente il programma eBPF al tracepoint
        \texttt{sys\_enter\_openat};
  \item rimanere in esecuzione per tutta la durata dell’esperimento.
\end{enumerate}

Questo laboratorio mostra in pratica come eBPF consenta non solo di
\emph{osservare} il comportamento del sistema (monitorando tutte le aperture
di file), ma anche di \emph{far rispettare} dinamicamente una politica di
sicurezza direttamente nel kernel, senza modificare il codice sorgente del
kernel stesso e con un overhead molto contenuto.


Il loader user-space si occupa di aprire, caricare e agganciare lo skeleton 
al tracepoint, quindi rimane in attesa indefinita, mentre l’output del 
programma viene visualizzato tramite \texttt{trace\_pipe}.

\newpage
\subsection{User Statically Defined Tracing (USDT)}
Le applicazioni possono definire tracepoint personalizzati, permettendo 
analisi non invasive anche senza modificare la logica applicativa. Un 
esempio classico è l’inserimento di un probe USDT su un’applicazione di 
login: ogni password errata genera un evento USDT, che un programma eBPF 
agganciato può intercettare per registrare tentativi falliti o analizzare 
le stringhe inserite.

\subsection{Kprobes e analisi dinamica del kernel}
I kprobe permettono di osservare l’esecuzione interna del kernel in punti 
non esposti da tracepoints. Un esempio didattico è l’aggancio alla funzione 
\texttt{do\_unlinkat} per monitorare le operazioni di cancellazione file. 
Monitorando questa funzione si può generare un evento ogni volta che un 
processo rimuove un file dal filesystem.

\subsection{Uprobes: analisi dinamica di applicazioni user-space}
Gli uprobes consentono di interceptare funzioni user-space a runtime. Il 
laboratorio prevede l'aggancio alla funzione \texttt{readline()} di Bash, per 
tracciare i comandi digitati dagli utenti. Ogni comando viene memorizzato 
in una mappa \texttt{BPF\_MAP\_TYPE\_PERCPU\_HASH}, evitando race condition 
multi-core. Questo consente di creare un contatore per ciascun comando 
eseguito nel sistema.

\subsection{Progetti reali basati su eBPF}
Numerosi progetti di livello enterprise utilizzano eBPF per sicurezza e 
osservabilità:
\begin{itemize}
  \item \textbf{Cilium}: CNI per Kubernetes, networking e sicurezza L3-L7.
  \item \textbf{Hubble}: osservabilità del networking nei cluster Cilium.
  \item \textbf{Tetragon}: security observability e runtime enforcement.
  \item \textbf{Symbiote, BPFDoor, Dewdrop, Bvp47}: esempi di impiego 
        malevolo di eBPF o filtri BPF per nascondere traffico, abilitare 
        backdoor o attivare accessi tramite pacchetti ``magici''.
\end{itemize}

\subsection{Abuso dei BPF filter: il caso BPFDoor}
BPFDoor è una backdoor avanzata che utilizza filtri BPF applicati ai socket 
per intercettare pacchetti contenenti ``magic numbers'' specifici. Grazie 
al fatto che i filtri BPF vengono eseguiti prima dello stack TCP/IP, la 
backdoor può attivarsi anche se un firewall blocca la comunicazione. Una 
volta ricevuto il pacchetto corretto, il malware apre una connessione 
inversa e fornisce una shell privilegiata all'attaccante. La complessità 
dei filtri aumenta con le versioni e supporta combinazioni multiple di TCP, 
UDP e ICMP.

\subsection{Conclusioni}
eBPF rappresenta uno strumento potentissimo che fonde osservabilità e 
sicurezza in un unico paradigma. Grazie all’aggancio efficiente a 
eventi kernel e user-space, eBPF permette di analizzare il comportamento 
dei sistemi in tempo reale e, allo stesso tempo, di agire proattivamente 
per bloccare attività malevole. Le sue applicazioni spaziano dalla 
visibilità nei cluster Kubernetes, al debugging profondo, fino alla 
rilevazione di malware avanzati.
